# this is just a handy global while fucking with the screen drawers
debug = Sprite();
fun printf (output) {
  debug.SetImage(Image.Text(output, 0.5, 0.5, 0.5, 1));
}

# used for drawing alternate mode up (or, you know, not)
status = "normal";

# distro info block
distro.name = "Fedora";
distro.version = "40";
distro.edition = "Workstation Edition";
distro.box = "box_fedora.png";

# this will need to match the steps in the shell script that rotated the bar
spinline.steps = 16;
# used for determining which set of squares to show on main and alternate screens.
style = "pro";
spinline.source = "spinner-srv"; # change this to spinner-pro if you like

# start with two colors (from 1x1 pngs)
white = Image("white.png");
gray = Image("gray.png");

# assuming a 640x480 screen, 60 should be the spinner centerline, so let's do some math.
# 30 is the largest common denominator there, so.
# that gets us 16 segments, and the bottom piece takes two.
H = Window.GetHeight();
W = Window.GetWidth();
spinline.center = H - ((H / 16) * 2);
spinline.alt = H - ((H/4) * 3);

# paint lower window.
bottom_size = H - spinline.center;
bottom = Sprite(gray.Scale(W, bottom_size));
bottom.SetX(0);
bottom.SetY(spinline.center);
bottom.SetZ(-6000);

# paint upper window.
top = Sprite(white.Scale(W, spinline.center));
top.SetX(0);
top.SetY(0);
top.SetZ(-10000);

# paint initial spinner
statbars_z = -900;
# scaling off 480 pixels high again
spinline.scale = H / 48;
for (i = 0 ; i < spinline.steps ; i++) {
  spinline.image[i] = Image(spinline.source + i + ".png").Scale(W, spinline.scale);
}
spinline.sprite = Sprite();
spinline.sprite.SetOpacity(0);
spinline.sprite.SetImage(spinline.image[0]);
spinline.sprite.SetPosition(0, 0 - spinline.scale, statbars_z);

# move the spinner
fun spinline_Move(pos) {
  spinline.sprite.SetOpacity(0);
  spinline.sprite.SetY(pos - (spinline.scale / 2));
  spinline.sprite.SetOpacity(1);
}
spinline_Move(spinline.center);

# animate the spinner
fun spinline_Animate (time) {
 spinline.sprite.SetImage(spinline.image[Math.Int(time * 2 % spinline.steps)]);
}

# paint boot progress
progress_box.image = Image("progress-box.png");
# divide lower area
bottom_step = Math.Int(bottom_size / 6);
# determine independent X/Y scaling to *deal* with protrait displays.
progress_box.scaleX = Math.Int(W / 3.939393);
progress_box.scaleY = Math.Int(bottom_step);
progress_box.sprite = Sprite(progress_box.image.Scale(progress_box.scaleX, progress_box.scaleY));
progress_box.posX = (W / 2) - (progress_box.scaleX / 2);
progress_box.posY = (spinline.center + bottom_step * 1.5);
progress_box.sprite.SetPosition(progress_box.posX, progress_box.posY, statbars_z);

# draw the progress bar *inside* the box
progress_bar.source = Image("progress-bar.png");
progress_bar.scaleX = progress_box.scaleX - 2;
progress_bar.scaleY = progress_box.scaleY - 4;
progress_bar.scaled = progress_bar.source.Scale(progress_bar.scaleX, progress_bar.scaleY);
progress_bar.sprite = Sprite();
progress_bar.posX = (progress_box.posX + 2);
progress_bar.posY = (progress_box.posY + 2);
progress_bar.sprite.SetPosition(progress_bar.posX, progress_bar.posY, statbars_z + 10);

# draw the progress bar by uncropping it
fun progbar_Advance (progress) {
  progress_bar.sprite.SetImage(progress_bar.scaled.Crop(0, 0, progress_bar.scaleX * progress, progress_bar.scaleY));
}

#----------------------------------------- Message --------------------------------
message_sprite = Sprite();

fun message (text) {
  global.W;
  global.message_sprite;
  global.spinline;
  global.bottom_step;

  local.source;
  local.scalef;
  local.scaled;

  source = Image.Text(text, 0, 0, 0, 1, "Libre Franklin Light 40");
  # proportinally scale the font to the height of bottom_step
  scalef = source.GetHeight() / bottom_step;
  scaled = source.Scale(source.GetWidth() * scalef, bottom_step);
  message_sprite.SetOpacity(0);
  message_sprite.SetImage(scaled);
  # position below the progress bar so it doesn't look really off. (it's really off.)
  message_sprite.SetPosition((W / 2) - (scaled.GetWidth() / 2), spinline.center + bottom_step * 3.5);
  message_sprite.SetOpacity(1);
}

# we should do something smarter, to hide the *previous* text, but...sounds hard.
fun starting (text) {
  message("Starting up...");
}

# we handle messages by replacing the startup text.
starting("up");

Plymouth.SetMessageFunction(message);
Plymouth.SetHideMessageFunction(starting);

# main images...
screen_ratio = H / W;
screen_center.x = W / 2;
screen_center.y = H / 2;
image = [];
mainimage_z = -5000;

# leaving this here for now because handy positioning lines
hline = Image("black.png").Scale(W, 1);
vline = Image("black.png").Scale(1, H);

fun image_sprite (id, origScaleX, origScaleY, origMidX, origMidY, squareEdge, origSquareX, origSquareY) {
  local.pos_sprite;
  global.H;
  global.screen_center;
  global.mainimage_z;
  global.image;
  # this is calculating the box that holds the OS logo, and everything can shift based on that.
  # the *sprite* is handy for debugging.
  pos_sprite.Y = Math.Int((H / 16) * 2);
  pos_sprite.size_edge = Math.Int((H / 16) * 6);	# because...it's a square
  pos_sprite.X = Math.Int(screen_center.x - (pos_sprite.size_edge / 2));
  #image[id].pos_sprite.sprite = Sprite(Image("black.png").Scale(pos_sprite.size_edge, pos_sprite.size_edge));
  #image[id].pos_sprite.sprite.SetPosition(pos_sprite.X, pos_sprite.Y, mainimage_z - 10);

  local.scale_factor;
  scale_factor = pos_sprite.size_edge / squareEdge;	# scale by the target box you can't easily see...

  local.mainimage;
  mainimage.source = Image("squares-" + id + ".png");
  mainimage.sizeX = Math.Int(scale_factor * mainimage.source.GetWidth());
  mainimage.sizeY = Math.Int(scale_factor * mainimage.source.GetHeight());
  mainimage.scaled = mainimage.source.Scale(mainimage.sizeX, mainimage.sizeY);
  image[id].sprite = Sprite();
  image[id].sprite.SetOpacity(0);
  image[id].sprite.SetImage(mainimage.scaled);
  # calculate these using the origSquareX/Y now.
  mainimage.posX = Math.Int(pos_sprite.X - (origSquareX * scale_factor));
  mainimage.posY = Math.Int(pos_sprite.Y - (origSquareY * scale_factor));
  image[id].sprite.SetPosition(mainimage.posX, mainimage.posY, mainimage_z);

  # handle the box inlay image
  global.distro;
  local.boxfill;
  local.boxspace;
  boxfill.source = Image(distro.box);
  # size we wish to put in box
  boxfill.px = Math.Int(pos_sprite.size_edge * 0.9);
  boxfill.scaled = boxfill.source.Scale(boxfill.px, boxfill.px);
  # place the box in the center of the empty space.
  boxspace.X = Math.Int(pos_sprite.X + (pos_sprite.size_edge / 2));
  boxspace.Y = Math.Int(pos_sprite.Y + (pos_sprite.size_edge / 2));
  boxfill.posX = boxspace.X - (boxfill.px / 2);
  boxfill.posY = boxspace.Y - (boxfill.px / 2);
  image[id].boxfill_sprite = Sprite();
  image[id].boxfill_sprite.SetOpacity(0);
  image[id].boxfill_sprite.SetImage(boxfill.scaled);
  image[id].boxfill_sprite.SetPosition(boxfill.posX, boxfill.posY, mainimage_z + 1);

  # oh boy. now to make plymouth draw pretty *text*
  # we want to left-align all the text, so we're gonna order the sprites
  # in that direction
  # we're gonna rely more on the height to sort out text scaling...
  local.text_right_align;
  local.text_top_boundary;
  local.text_scale_target;
  local.text_target_size;
  local.pixel_shift;
  # adjust the multipliers here to shift by more pixels, if you like
  if (id == "srv") {
    pixel_shift = -60;
  } else {
    pixel_shift = 1;
  }
  text_right_align = Math.Int((scale_factor * pixel_shift) + pos_sprite.X + mainimage.scaled.GetWidth());
  text_top_boundary = Math.Int(mainimage.posY + mainimage.sizeY);
  text_scale_target = Math.Int(H / 9);
  text_target_size = 64;

  # we put the space with the version number so it's condensed to shit
  local.version;
  version.text = Image.Text(" " + distro.version, 0, 0, 0, 1, "Libre Franklin Regular 80");
  # fuck with the X scale to compress the version number (emulate narrow font?)
  version.sizeY = Math.Int(version.text.GetHeight() / text_target_size * text_scale_target * 0.5);
  # !!! below is reused for aligning the *next row* (edition) of text too !!!
  version.sizeX = Math.Int(text_scale_target);
  version.scaled = version.text.Scale(version.sizeX, version.sizeY);
  image[id].version_sprite = Sprite();
  image[id].version_sprite.SetOpacity(0);
  image[id].version_sprite.SetImage(version.scaled);
  image[id].version_sprite.SetPosition(text_right_align,
                                       text_top_boundary,
                                       mainimage_z);

  local.dt;
  dt.source = Image.Text(distro.name, 0, 0, 0, 1, "Libre Franklin Black 100");
  # we're not trying to condense the distro name, notably.
  dt.sizeX = Math.Int(dt.source.GetHeight() / text_target_size * text_scale_target);
  # in fact we made it bigger
  dt.sizeY = Math.Int(text_scale_target * 1.2);
  dt.scaled = dt.source.Scale(dt.sizeX, dt.sizeY);
  image[id].distro_sprite = Sprite();
  image[id].distro_sprite.SetOpacity(0);
  image[id].distro_sprite.SetImage(dt.scaled);
  image[id].distro_sprite.SetPosition(text_right_align - dt.sizeX,
                                      # compensate for us making the text bigger
                                      Math.Int(text_top_boundary - (dt.sizeY * 0.1)),
                                      mainimage_z);

  local.edition;
  edition.text = Image.Text(distro.edition, 0, 0, 0, 1, "Libre Franklin Black 90");
  edition.sizeX = Math.Int(edition.text.GetHeight() / text_target_size * text_scale_target);
  # scrungle
  edition.sizeY = Math.Int(text_scale_target * 0.5);
  edition.scaled = edition.text.Scale(edition.sizeX, edition.sizeY);
  image[id].edition_sprite = Sprite();
  image[id].edition_sprite.SetOpacity(0);
  image[id].edition_sprite.SetImage(edition.scaled);
  image[id].edition_sprite.SetPosition(text_right_align + (version.sizeX / 2) - edition.sizeX,
                                       text_top_boundary + version.sizeY - (edition.sizeY / 2),
                                       mainimage_z);
}

# enable a logo and associated text
fun image_reveal (id, opacity) {
  image[id].sprite.SetOpacity(opacity);
  image[id].version_sprite.SetOpacity(opacity);
  image[id].distro_sprite.SetOpacity(opacity);
  image[id].edition_sprite.SetOpacity(opacity);
  image[id].boxfill_sprite.SetOpacity(opacity);
  # the positioning sprite shouldn't be normally defined
  image[id].pos_sprite.SetOpacity(opacity * 0.5);
}

# the first two args are scale factors from the source image
# the next two args are positioning in the source image relative to the
# screen center.
# all the numbers around this and the function are *kinda right* don't be picky.
# the fifth argument here is the size of the side of a square inside the nest...
# and the two args after that are the x/y of where that square begins.
image_sprite("pro", 3.0622, 2.448979, -54, -146, 145, 20, 13);
image_sprite("srv", 2.75862, 2.448979, -123, -165, 131, 55, 18);

# something that sorks as the alternate rendering (for verbose/status boots)
alt_images = [];
altimage_z = -4000;
altarea_ratio = spinline.alt / W;

fun image_altsprite(id, squareEdge, origSquareX, origSquareY) {
  # now, out of the top bar space, we use about 5/6? let's try it.
  # we're gonna focus a lot on spinline.alt as a holder.
  alt_images[id].destHeight = Math.Int((spinline.alt / 6) * 4);
  alt_images[id].source = Image("squares-alt-" + id + ".png");
  alt_images[id].scaleX = Math.Int((alt_images[id].destHeight / alt_images[id].source.GetHeight()) * alt_images[id].source.GetWidth());
  alt_images[id].scaled = alt_images[id].source.Scale(alt_images[id].scaleX, alt_images[id].destHeight);
  alt_images[id].posX = W / 6;
  alt_images[id].posY = (spinline.alt / 2) - (alt_images[id].destHeight / 2);
  alt_images[id].sprite = Sprite();
  alt_images[id].sprite.SetOpacity(0);
  alt_images[id].sprite.SetImage(alt_images[id].scaled);
  alt_images[id].sprite.SetPosition(alt_images[id].posX, alt_images[id].posY, altimage_z);

  # handle the box inlay image
  alt_images[id].scale_factor = (alt_images[id].scaled.GetWidth() / alt_images[id].source.GetWidth());
  alt_images[id].boxedge_px = Math.Int(squareEdge * alt_images[id].scale_factor);
  # size we wish to put in box
  alt_images[id].boxfill_px = Math.Int(alt_images[id].boxedge_px * 0.9);
  alt_images[id].boxfill_scaled = image[id].boxfill_source.Scale(alt_images[id].boxfill_px, alt_images[id].boxfill_px);
  # place the box in the center of the empty space.
  alt_images[id].boxspace_centerX = Math.Int(alt_images[id].posX + (origSquareX * alt_images[id].scale_factor) + (alt_images[id].boxedge_px / 2));
  alt_images[id].boxspace_centerY = Math.Int(alt_images[id].posY + (origSquareY * alt_images[id].scale_factor) + (alt_images[id].boxedge_px / 2));
  alt_images[id].boxfill_X = alt_images[id].boxspace_centerX - (alt_images[id].boxfill_px / 2);
  alt_images[id].boxfill_Y = alt_images[id].boxspace_centerY - (alt_images[id].boxfill_px / 2);
  alt_images[id].boxfill_sprite = Sprite();
  alt_images[id].boxfill_sprite.SetOpacity(0);
  alt_images[id].boxfill_sprite.SetImage(alt_images[id].boxfill_scaled);
  alt_images[id].boxfill_sprite.SetPosition(alt_images[id].boxfill_X, alt_images[id].boxfill_Y, altimage_z + 1);

  # we stole the text from the main image...
  alt_images[id].version_scaleY = Math.Int(alt_images[id].destHeight / 1.35);
  alt_images[id].version_scaleX = Math.Int((alt_images[id].version_scaleY / image[id].version_text.GetHeight()) * image[id].version_text.GetWidth());
  alt_images[id].version_scaled = image[id].version_text.Scale(alt_images[id].version_scaleX, alt_images[id].version_scaleY);
  alt_images[id].version_sprite = Sprite();
  alt_images[id].version_sprite.SetOpacity(0);
  alt_images[id].version_sprite.SetImage(alt_images[id].version_scaled);
  alt_images[id].version_sprite.SetPosition((alt_images[id].posX * 5) - alt_images[id].version_scaleX,
                                            Math.Int(((spinline.alt / 3) * 2) - (alt_images[id].version_scaleY * 0.9)),
                                            altimage_z);

  alt_images[id].distro_scaleY = Math.Int(alt_images[id].destHeight);
  alt_images[id].distro_scaleX = Math.Int((alt_images[id].distro_scaleY / image[id].distro_text.GetHeight()) * image[id].distro_text.GetWidth());
  alt_images[id].distro_scaled = image[id].distro_text.Scale(alt_images[id].distro_scaleX, alt_images[id].distro_scaleY);
  alt_images[id].distro_sprite = Sprite();
  alt_images[id].distro_sprite.SetOpacity(0);
  alt_images[id].distro_sprite.SetImage(alt_images[id].distro_scaled);
  alt_images[id].distro_sprite.SetPosition((alt_images[id].posX * 5) - alt_images[id].version_scaleX - alt_images[id].distro_scaleX,
                                           Math.Int(((spinline.alt / 3) * 2) - alt_images[id].distro_scaleY + (alt_images[id].distro_scaleY / 8)),
                                           altimage_z);

  alt_images[id].edition_scaleI = Math.Int(alt_images[id].destHeight);
  alt_images[id].edition_scaleY = Math.Int(alt_images[id].edition_scaleI * 0.28);
  alt_images[id].edition_scaleX = Math.Int((alt_images[id].edition_scaleI / image[id].edition_text.GetHeight()) * image[id].version_text.GetWidth());
  alt_images[id].edition_scaled = image[id].edition_text.Scale(alt_images[id].edition_scaleX, alt_images[id].edition_scaleY);
  alt_images[id].edition_sprite = Sprite();
  alt_images[id].edition_sprite.SetOpacity(0);
  alt_images[id].edition_sprite.SetImage(alt_images[id].edition_scaled);
  alt_images[id].edition_sprite.SetPosition((alt_images[id].posX * 5) - alt_images[id].edition_scaleX,
                                            Math.Int(((spinline.alt / 3) * 2) - (alt_images[id].edition_scaleY / 3)),
                                            altimage_z);
}

fun alt_reveal (id, opacity) {
  alt_images[id].sprite.SetOpacity(opacity);
  alt_images[id].version_sprite.SetOpacity(opacity);
  alt_images[id].distro_sprite.SetOpacity(opacity);
  alt_images[id].edition_sprite.SetOpacity(opacity);
  alt_images[id].boxfill_sprite.SetOpacity(opacity);
}

#image_altsprite("pro", 55, 5, 5);
#image_altsprite("srv", 58, 39, 11);

# MAIN SCREEN TURN ON
image_reveal(style, 1);
#alt_reveal(style, 1);
#spinline_Move(spinline.alt);

# hook the boot progress callback to update the spinner, progress bar
fun progress_callback (time, prog) {
  spinline_Animate(time);
  progbar_Advance(prog);
}
Plymouth.SetBootProgressFunction(progress_callback);

#----------------------------------------- Dialog --------------------------------

# we call on the dialog we haven't made yet (to turn it off) for normal callbacks.
fun display_normal_callback () {
  global.status = "normal";
  if (global.dialog) {
    dialog_opacity (0);
  }

  alt_reveal(style, 0);
  spinline_Move(spinline.center);
  image_reveal(style, 1);

}
Plymouth.SetDisplayNormalFunction(display_normal_callback);

fun dialog_setup() {
  image_reveal(style, 0);
  spinline_Move(spinline.alt);
  alt_reveal(style, 1);

  local.box;
  local.lock;
  local.entry;
 
  box.image = Image("box.png");
  lock.image = Image("lock.png");
  entry.image = Image("entry.png");
 
  box.sprite = Sprite(box.image);
  box.x = Window.GetWidth()  / 2 - box.image.GetWidth ()/2;
  box.y = Window.GetHeight() / 4 - box.image.GetHeight()/4;
  box.z = 10000;
  box.sprite.SetPosition(box.x, box.y, box.z);
    
  # scale the lock with the box height
  lock.scale_factor = box.image.GetHeight() / lock.image.GetHeight() * 0.75;
  lock.scaled = lock.image.Scale(lock.image.GetWidth()  * lock.scale_factor,
                                 lock.image.GetHeight() * lock.scale_factor);
  lock.sprite = Sprite(lock.scaled);
  
  lock.x = box.x + box.image.GetWidth()/2 - (lock.scaled.GetWidth() + entry.image.GetWidth()) / 2;
  lock.y = box.y + box.image.GetHeight()/2 - lock.scaled.GetHeight()/2;
  lock.z = box.z + 1;
  lock.sprite.SetPosition(lock.x, lock.y, lock.z);
    
  entry.sprite = Sprite(entry.image);
  entry.x = lock.x + lock.scaled.GetWidth();
  entry.y = box.y + box.image.GetHeight()/2 - entry.image.GetHeight()/2;
  entry.z = box.z + 1;
  entry.sprite.SetPosition(entry.x, entry.y, entry.z);
    
  global.dialog.box = box;
  global.dialog.lock = lock;
  global.dialog.entry = entry;
  global.dialog.bullet_image = Image("bullet.png");
  dialog_opacity (1);
}
    
fun dialog_opacity(opacity) {
  dialog.box.sprite.SetOpacity (opacity);
  dialog.lock.sprite.SetOpacity (opacity);
  dialog.entry.sprite.SetOpacity (opacity);
  for (index = 0; dialog.bullet[index]; index++) {
    dialog.bullet[index].sprite.SetOpacity(opacity);
  }
}


fun display_password_callback (prompt, bullets) {
  global.status = "password";
  if (!global.dialog)
  dialog_setup();
  else
  dialog_opacity(1);
  for (index = 0; dialog.bullet[index] || index < bullets; index++) {
    if (!dialog.bullet[index]) {
      dialog.bullet[index].sprite = Sprite(dialog.bullet_image);
      dialog.bullet[index].x = dialog.entry.x + index * dialog.bullet_image.GetWidth();
      dialog.bullet[index].y = dialog.entry.y + dialog.entry.image.GetHeight() / 2 - dialog.bullet_image.GetHeight() / 2;
      dialog.bullet[index].z = dialog.entry.z + 1;
      dialog.bullet[index].sprite.SetPosition(dialog.bullet[index].x, dialog.bullet[index].y, dialog.bullet[index].z);
    }
    if (index < bullets) {
      dialog.bullet[index].sprite.SetOpacity(1);
    } else {
      dialog.bullet[index].sprite.SetOpacity(0);
    }
  }
}

Plymouth.SetDisplayPasswordFunction(display_password_callback);

#----------------------------------------- Quit --------------------------------

fun quit_callback () {}
Plymouth.SetQuitFunction(quit_callback);
