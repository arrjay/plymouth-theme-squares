# this is just a handy global while fucking with the screen drawers
debug = Sprite();
fun printf (output) {
  debug.SetImage(Image.Text(output, 0.5, 0.5, 0.5, 1));
}

# used for drawing alternate mode up (or, you know, not)
status = "normal";

# distro info block
distro.name = "Fedora";
distro.version = "40";
distro.edition = "Workstation";
distro.box = "box_fedora.png";

# this will need to match the steps in the shell script that rotated the bar
spinline.steps = 16;
# used for determining which set of squares to show on main and alternate screens.
style = "pro";
spinline.source = "spinner-srv"; # change this to spinner-pro if you like

# start with two colors (from 1x1 pngs)
white = Image("white.png");
gray = Image("gray.png");

# assuming a 640x480 screen, 60 should be the spinner centerline, so let's do some math.
# 30 is the largest common denominator there, so.
# that gets us 16 segments, and the bottom piece takes two.
H = Window.GetHeight();
W = Window.GetWidth();
spinline.center = H - ((H / 16) * 2);
spinline.alt = H - ((H/4) * 3);

# paint lower window.
bottom_size = H - spinline.center;
bottom = Sprite(gray.Scale(W, bottom_size));
bottom.SetX(0);
bottom.SetY(spinline.center);
bottom.SetZ(-6000);

# paint upper window.
top = Sprite(white.Scale(W, spinline.center));
top.SetX(0);
top.SetY(0);
top.SetZ(-10000);

# paint initial spinner
statbars_z = -900;
# scaling off 480 pixels high again
spinline.scale = H / 48;
for (i = 0 ; i < spinline.steps ; i++) {
  spinline.image[i] = Image(spinline.source + i + ".png").Scale(W, spinline.scale);
}
spinline.sprite = Sprite();
spinline.sprite.SetOpacity(0);
spinline.sprite.SetImage(spinline.image[0]);
spinline.sprite.SetPosition(0, 0 - spinline.scale, statbars_z);

# move the spinner
fun spinline_Move(pos) {
  spinline.sprite.SetOpacity(0);
  spinline.sprite.SetY(pos - (spinline.scale / 2));
  spinline.sprite.SetOpacity(1);
}
spinline_Move(spinline.center);

# animate the spinner
fun spinline_Animate (time) {
 spinline.sprite.SetImage(spinline.image[Math.Int(time * 2 % spinline.steps)]);
}

# paint boot progress
progress_box.image = Image("progress-box.png");
# divide lower area
bottom_step = Math.Int(bottom_size / 6);
# determine independent X/Y scaling to *deal* with protrait displays.
progress_box.scaleX = Math.Int(W / 3.939393);
progress_box.scaleY = Math.Int(bottom_step);
progress_box.sprite = Sprite(progress_box.image.Scale(progress_box.scaleX, progress_box.scaleY));
progress_box.posX = (W / 2) - (progress_box.scaleX / 2);
progress_box.posY = (spinline.center + bottom_step * 1.5);
progress_box.sprite.SetPosition(progress_box.posX, progress_box.posY, statbars_z);

# draw the progress bar *inside* the box
progress_bar.source = Image("progress-bar.png");
progress_bar.scaleX = progress_box.scaleX - 2;
progress_bar.scaleY = progress_box.scaleY - 4;
progress_bar.scaled = progress_bar.source.Scale(progress_bar.scaleX, progress_bar.scaleY);
progress_bar.sprite = Sprite();
progress_bar.posX = (progress_box.posX + 2);
progress_bar.posY = (progress_box.posY + 2);
progress_bar.sprite.SetPosition(progress_bar.posX, progress_bar.posY, statbars_z + 10);

# draw the progress bar by uncropping it
fun progbar_Advance (progress) {
  progress_bar.sprite.SetImage(progress_bar.scaled.Crop(0, 0, progress_bar.scaleX * progress, progress_bar.scaleY));
}

#----------------------------------------- Message --------------------------------
message_sprite = Sprite();

fun message (text) {
  source = Image.Text(text, 0, 0, 0, 1, "Libre Franklin Light");
  # proportinally scale the font to the height of bottom_step
  scalef = source.GetHeight() / bottom_step;
  scaled = source.Scale(source.GetWidth() * scalef, source.GetHeight() * scalef);
  message_sprite.SetOpacity(0);
  message_sprite.SetImage(scaled);
  # position below the progress bar so it doesn't look really off. (it's really off.)
  message_sprite.SetPosition((W / 2) - (scaled.GetWidth() / 2), spinline.center + bottom_step * 3);
  message_sprite.SetOpacity(1);
}

# we should do something smarter, to hide the *previous* text, but...sounds hard.
fun starting (text) {
  message("Starting up...");
}

# we handle messages by replacing the startup text.
starting("up");

Plymouth.SetMessageFunction(message);
Plymouth.SetHideMessageFunction(starting);

# main images...
screen_ratio = H / W;
screen_center.x = W / 2;
screen_center.y = H / 2;
image = [];
mainimage_z = -5000;

fun image_sprite (id, origScaleX, origScaleY, origMidX, origMidY, squareEdge, origSquareX, origSquareY) {
  image[id].source = Image("squares-" + id + ".png");
  # we want to keep the image aspect as it is, so figure out the bigger of the
  # dimensions on screen and scale in proportion
  image[id].ratio = image[id].source.GetHeight() / image[id].source.GetWidth();
  if (screen_ratio > image[id].ratio) {
    image[id].scale_factor = origScaleX * image[id].ratio * 0.9;
  } else {
    image[id].scale_factor = origScaleY * image[id].ratio * 0.9;
  }
  image[id].scaleMidX = Math.Int(image[id].scale_factor * origMidX);
  image[id].scaleMidY = Math.Int(image[id].scale_factor * origMidY);
  image[id].scaleSizeX = Math.Int(image[id].scale_factor * image[id].source.GetWidth());
  image[id].scaleSizeY = Math.Int(image[id].scale_factor * image[id].source.GetHeight());
  image[id].scaled = image[id].source.Scale(image[id].scaleSizeX, image[id].scaleSizeY);
  image[id].sprite = Sprite();
  image[id].sprite.SetOpacity(0);
  image[id].sprite.SetImage(image[id].scaled);
  image[id].sprite.SetPosition(screen_center.x + image[id].scaleMidX, screen_center.y + image[id].scaleMidY, mainimage_z);

  # handle the box inlay image
  image[id].boxfill_source = Image(distro.box);
  # size of empty box
  image[id].boxedge_px = Math.Int(squareEdge * image[id].scale_factor);
  # size we wish to put in box
  image[id].boxfill_px = Math.Int(image[id].boxedge_px * 0.9);
  image[id].boxfill_scaled = image[id].boxfill_source.Scale(image[id].boxfill_px, image[id].boxfill_px);
  # place the box in the center of the empty space.
  image[id].boxspace_centerX = Math.Int(screen_center.x + image[id].scaleMidX + (origSquareX * image[id].scale_factor) + (image[id].boxedge_px / 2));
  image[id].boxspace_centerY = Math.Int(screen_center.y + image[id].scaleMidY + (origSquareY * image[id].scale_factor) + (image[id].boxedge_px / 2));
  image[id].boxfill_X = image[id].boxspace_centerX - (image[id].boxfill_px / 2);
  image[id].boxfill_Y = image[id].boxspace_centerY - (image[id].boxfill_px / 2);
  image[id].boxfill_sprite = Sprite();
  image[id].boxfill_sprite.SetOpacity(0);
  image[id].boxfill_sprite.SetImage(image[id].boxfill_scaled);
  image[id].boxfill_sprite.SetPosition(image[id].boxfill_X, image[id].boxfill_Y, mainimage_z + 1);

  # oh boy. now to make plymouth draw pretty *text*
  # we want to left-align all the text, so we're gonna order the sprites
  # in that direction
  # we're gonna rely more on the height to sort out text scaling...
  image[id].text_scale_target = Math.Int(H / 9);
  image[id].text_target_size = 64;
  # now, for positioning we want to hang off the _bottom_ of our image a bit.
  image[id].text_anchor_x = screen_center.x + image[id].scaleSizeX / 2 + (image[id].text_target_size * 2.5);
  image[id].text_anchor_y = screen_center.y + image[id].scaleMidY + image[id].scaleSizeY + image[id].text_target_size * 0.2;

  # we put the space with the version number so it's condensed to shit
  image[id].version_text = Image.Text(" " + distro.version, 0, 0, 0, 1, "Libre Franklin Regular 80");
  # fuck with the X scale to compress the version number (emulate narrow font?)
  image[id].version_scaleX = Math.Int(image[id].version_text.GetHeight() / image[id].text_target_size * image[id].text_scale_target * 0.5);
  image[id].version_scaleY = Math.Int(image[id].text_scale_target);
  image[id].version_scaled = image[id].version_text.Scale(image[id].version_scaleX, image[id].version_scaleY);
  image[id].version_sprite = Sprite();
  image[id].version_sprite.SetOpacity(0);
  image[id].version_sprite.SetImage(image[id].version_scaled);
  image[id].version_sprite.SetPosition(image[id].text_anchor_x - image[id].version_scaleX,
                                       image[id].text_anchor_y,
                                       mainimage_z);

  image[id].distro_text = Image.Text(distro.name, 0, 0, 0, 1, "Libre Franklin Black 100");
  # we're not trying to condense the distro name, notably.
  image[id].distro_scaleX = Math.Int(image[id].distro_text.GetHeight() / image[id].text_target_size * image[id].text_scale_target);
  # in fact we made it bigger
  image[id].distro_scaleY = Math.Int(image[id].text_scale_target * 1.2);
  image[id].distro_scaled = image[id].distro_text.Scale(image[id].distro_scaleX, image[id].distro_scaleY);
  image[id].distro_sprite = Sprite();
  image[id].distro_sprite.SetOpacity(0);
  image[id].distro_sprite.SetImage(image[id].distro_scaled);
  image[id].distro_sprite.SetPosition(image[id].text_anchor_x - image[id].version_scaleX - image[id].distro_scaleX,
                                      # align with the distro_version sprite...?
                                      image[id].text_anchor_y + (image[id].version_scaleY + 2) - image[id].distro_scaleY,
                                      mainimage_z);

  image[id].edition_text = Image.Text(distro.edition, 0, 0, 0, 1, "Libre Franklin Black 90");
  image[id].edition_scaleX = Math.Int(image[id].edition_text.GetHeight() / image[id].text_target_size * image[id].text_scale_target);
  # scrungle
  image[id].edition_scaleY = Math.Int(image[id].text_scale_target * 0.5);
  image[id].edition_scaled = image[id].edition_text.Scale(image[id].edition_scaleX, image[id].edition_scaleY);
  image[id].edition_sprite = Sprite();
  image[id].edition_sprite.SetOpacity(0);
  image[id].edition_sprite.SetImage(image[id].edition_scaled);
  image[id].edition_sprite.SetPosition(image[id].text_anchor_x - image[id].edition_scaleX,
                                       image[id].text_anchor_y + image[id].distro_scaleY - image[id].edition_scaleY + 2,
                                       mainimage_z);
}

# enable a logo and associated text
fun image_reveal (id, opacity) {
  image[id].sprite.SetOpacity(opacity);
  image[id].version_sprite.SetOpacity(opacity);
  image[id].distro_sprite.SetOpacity(opacity);
  image[id].edition_sprite.SetOpacity(opacity);
  image[id].boxfill_sprite.SetOpacity(opacity);
}

# something that sorks as the alternate rendering (for verbose/status boots)
alt_images = [];
altimage_z = -4000;
fun image_altsprite(id) {
}

# the first two args are scale factors from the source image
# the next two args are positioning in the source image relative to the
# screen center.
# all the numbers around this and the function are *kinda right* don't be picky.
# the fifth argument here is the size of the side of a square inside the nest...
# and the two args after that are the x/y of where that square begins.
image_sprite("pro", 3.0622, 2.448979, -54, -146, 145, 20, 13);
image_sprite("srv", 2.75862, 2.448979, -123, -165, 131, 55, 18);

# MAIN SCREEN TURN ON
image_reveal(style, 1);

# hook the boot progress callback to update the spinner, progress bar
fun progress_callback (time, prog) {
  spinline_Animate(time);
  progbar_Advance(prog);
}
Plymouth.SetBootProgressFunction(progress_callback);

#----------------------------------------- Dialog --------------------------------

# we call on the dialog we haven't made yet (to turn it off) for normal callbacks.
fun display_normal_callback () {
  global.status = "normal";
  if (global.dialog) {
    dialog_opacity (0);
  }
}
Plymouth.SetDisplayNormalFunction(display_normal_callback);

fun dialog_setup() {
  local.box;
  local.lock;
  local.entry;
 
  box.image = Image("box.png");
  lock.image = Image("lock.png");
  entry.image = Image("entry.png");
 
  box.sprite = Sprite(box.image);
  box.x = Window.GetWidth()  / 2 - box.image.GetWidth ()/2;
  box.y = Window.GetHeight() / 4 - box.image.GetHeight()/4;
  box.z = 10000;
  box.sprite.SetPosition(box.x, box.y, box.z);
    
  # scale the lock with the box height
  lock.scale_factor = box.image.GetHeight() / lock.image.GetHeight() * 0.75;
  lock.scaled = lock.image.Scale(lock.image.GetWidth()  * lock.scale_factor,
                                 lock.image.GetHeight() * lock.scale_factor);
  lock.sprite = Sprite(lock.scaled);
  
  lock.x = box.x + box.image.GetWidth()/2 - (lock.scaled.GetWidth() + entry.image.GetWidth()) / 2;
  lock.y = box.y + box.image.GetHeight()/2 - lock.scaled.GetHeight()/2;
  lock.z = box.z + 1;
  lock.sprite.SetPosition(lock.x, lock.y, lock.z);
    
  entry.sprite = Sprite(entry.image);
  entry.x = lock.x + lock.scaled.GetWidth();
  entry.y = box.y + box.image.GetHeight()/2 - entry.image.GetHeight()/2;
  entry.z = box.z + 1;
  entry.sprite.SetPosition(entry.x, entry.y, entry.z);
    
  global.dialog.box = box;
  global.dialog.lock = lock;
  global.dialog.entry = entry;
  global.dialog.bullet_image = Image("bullet.png");
  dialog_opacity (1);
}
    
fun dialog_opacity(opacity) {
  dialog.box.sprite.SetOpacity (opacity);
  dialog.lock.sprite.SetOpacity (opacity);
  dialog.entry.sprite.SetOpacity (opacity);
  for (index = 0; dialog.bullet[index]; index++) {
    dialog.bullet[index].sprite.SetOpacity(opacity);
  }
}


fun display_password_callback (prompt, bullets) {
  global.status = "password";
  if (!global.dialog)
  dialog_setup();
  else
  dialog_opacity(1);
  for (index = 0; dialog.bullet[index] || index < bullets; index++) {
    if (!dialog.bullet[index]) {
      dialog.bullet[index].sprite = Sprite(dialog.bullet_image);
      dialog.bullet[index].x = dialog.entry.x + index * dialog.bullet_image.GetWidth();
      dialog.bullet[index].y = dialog.entry.y + dialog.entry.image.GetHeight() / 2 - dialog.bullet_image.GetHeight() / 2;
      dialog.bullet[index].z = dialog.entry.z + 1;
      dialog.bullet[index].sprite.SetPosition(dialog.bullet[index].x, dialog.bullet[index].y, dialog.bullet[index].z);
    }
    if (index < bullets) {
      dialog.bullet[index].sprite.SetOpacity(1);
    } else {
      dialog.bullet[index].sprite.SetOpacity(0);
    }
  }
}

Plymouth.SetDisplayPasswordFunction(display_password_callback);

#----------------------------------------- Quit --------------------------------

fun quit_callback () {}
Plymouth.SetQuitFunction(quit_callback);
